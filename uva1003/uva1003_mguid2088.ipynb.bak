{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import collections\n",
    "import math\n",
    "import sys\n",
    "from PIL import Image, ImageDraw\n",
    "from IPython.core.display import display\n",
    "\n",
    "epsilon = 1e-9\n",
    "Tree = collections.namedtuple('Tree', 'x,y,d,h')\n",
    "\n",
    "class ObstacleSet(object):\n",
    "  def __init__(self, r1, h1, x_min, x_max, y_min, y_max):\n",
    "    self.r1, self.h1, self.max_reach, self.x_min, self.x_max, self.y_min, self.y_max = r1, h1, math.sqrt(r1*r1+h1*h1), 8.0*x_min, 8.0*x_max, 8.0*y_min, 8.0*y_max\n",
    "    self._angles = []\n",
    "    \n",
    "  def add_fence(self, distance, offset, tree, draw):\n",
    "    if self.max_reach >= distance + epsilon:\n",
    "      angle = math.acos(distance / self.max_reach) + math.atan(self.r1 / self.h1)\n",
    "      draw.pieslice([8.0*(tree.x-self.max_reach), 8.0*(tree.y-self.max_reach),8.0*(tree.x+self.max_reach), 8.0*(tree.y+self.max_reach)],\n",
    "                    ((360 + (offset * 180/math.pi)) - ((-angle) * (180.0/math.pi))), ((360 + (offset * 180/math.pi)) -((angle)*(180.0/math.pi))), outline=(0,255,0))\n",
    "      self._angles.append((-angle + offset, angle + offset))\n",
    "  def add_tree(self, distance, r2, offset, tree, draw):\n",
    "    if self.max_reach >= distance - r2 + epsilon:\n",
    "      angle = math.asin((self.r1 + r2) / distance)\n",
    "      draw.pieslice([8.0*(tree.x-self.max_reach), 8.0*(tree.y-self.max_reach),8.0*(tree.x+self.max_reach), 8.0*(tree.y+self.max_reach)],\n",
    "                    ((360 + (offset * 180/math.pi)) - ((-angle) * (180.0/math.pi))), ((360 + (offset * 180/math.pi)) -((angle)*(180.0/math.pi))), outline=(0,255,0))\n",
    "      self._angles.append((-angle + offset, angle + offset))\n",
    "  def has_gap(self, tree, draw):\n",
    "    for i in range(len(self._angles)):\n",
    "      ##print(i)\n",
    "      left, right = self._angles[i]\n",
    "      \n",
    "      left = math.fmod(left, 2.0 * math.pi)\n",
    "      if left < 0.0:\n",
    "        left += 2.0 * math.pi\n",
    "      right = math.fmod(right, 2.0 * math.pi)\n",
    "      if right < 0.0:\n",
    "        right += 2.0 * math.pi\n",
    "      if left <= right:\n",
    "        self._angles[i] = (left, right)\n",
    "      else:\n",
    "        self._angles[i] = (left, 2.0 * math.pi)\n",
    "        self._angles.append((0.0, right))\n",
    "    self._angles.sort()\n",
    "    limit = 0.0\n",
    "    for left, right in self._angles:\n",
<<<<<<< HEAD
    "      ##points on circle  \n",
    "      x4 = 8.0 * (tree.x + (0.5 * tree.d) * math.cos(left+0.5 *math.pi) - (0.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "      y4 = 8.0 * (tree.y + (0.0 * tree.h) * math.cos(left+0.5 *math.pi) + (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "      x3 = 8.0 * (tree.x - (0.5 * tree.d) * math.cos(left+0.5 *math.pi) - (0.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "      y3 = 8.0 * (tree.y + (0.0 * tree.h) * math.cos(left+0.5 *math.pi) - (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "      ##the other ones\n",
    "      x1 = 8.0 * (tree.x + (0.5 * tree.d) * math.cos(left+0.5 *math.pi) + (1.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "      y1 = 8.0 * (tree.y - (1.0 * tree.h) * math.cos(left+0.5 *math.pi) + (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "      x2 = 8.0 * (tree.x - (0.5 * tree.d) * math.cos(left+0.5 *math.pi) + (1.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "      y2 = 8.0 * (tree.y - (1.0 * tree.h) * math.cos(left+0.5 *math.pi) - (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "      ##if x1 >= self.x_min and x1 <= self.x_max and y1 >= self.x_min and y1 <= self.y_max and x2 >= self.y_min and x2 <= self.x_max and y2 >= self.y_min and y2 <= self.y_max:  \n",
    "      draw.polygon((x1,y1,x2,y2,x3,y3,x4,y4), outline=(255,0,0))\n",
    "      ##points on circle\n",
    "      x4 = 8.0 * (tree.x + (0.5 * tree.d) * math.cos(right+0.5 *math.pi) - (0.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "      y4 = 8.0 * (tree.y + (0.0 * tree.h) * math.cos(right+0.5 *math.pi) + (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "      x3 = 8.0 * (tree.x - (0.5 * tree.d) * math.cos(right+0.5 *math.pi) - (0.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "      y3 = 8.0 * (tree.y + (0.0 * tree.h) * math.cos(right+0.5 *math.pi) - (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "      ##the other ones\n",
    "      x1 = 8.0 * (tree.x + (0.5 * tree.d) * math.cos(right+0.5 *math.pi) + (1.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "      y1 = 8.0 * (tree.y - (1.0 * tree.h) * math.cos(right+0.5 *math.pi) + (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "      x2 = 8.0 * (tree.x - (0.5 * tree.d) * math.cos(right+0.5 *math.pi) + (1.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "      y2 = 8.0 * (tree.y - (1.0 * tree.h) * math.cos(right+0.5 *math.pi) - (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "      ##if x1 >= self.x_min and x1 <= self.x_max and y1 >= self.x_min and y1 <= self.y_max and x2 >= self.y_min and x2 <= self.x_max and y2 >= self.y_min and y2 <= self.y_max:  \n",
    "      draw.polygon((x1,y1,x2,y2,x3,y3,x4,y4), outline=(255,0,0))\n",
=======
>>>>>>> bf85dae5a7fb336b93d5b96af2008e9d90561173
    "      if left > limit + epsilon:\n",
    "        x4 = 4.0 * (tree.x + (0.5 * tree.d) * math.cos(left+0.5 *math.pi) - (0.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "        y4 = 4.0 * (tree.y + (0.0 * tree.h) * math.cos(left+0.5 *math.pi) + (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "        x3 = 4.0 * (tree.x - (0.5 * tree.d) * math.cos(left+0.5 *math.pi) - (0.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "        y3 = 4.0 * (tree.y + (0.0 * tree.h) * math.cos(left+0.5 *math.pi) - (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "        x1 = 4.0 * (tree.x + (0.5 * tree.d) * math.cos(left+0.5 *math.pi) + (1.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "        y1 = 4.0 * (tree.y - (1.0 * tree.h) * math.cos(left+0.5 *math.pi) + (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "        x2 = 4.0 * (tree.x - (0.5 * tree.d) * math.cos(left+0.5 *math.pi) + (1.0 * tree.h) * math.sin(left+0.5 *math.pi))\n",
    "        y2 = 4.0 * (tree.y - (1.0 * tree.h) * math.cos(left+0.5 *math.pi) - (0.5 * tree.d) * math.sin(left+0.5 *math.pi))\n",
    "        ##print(x1)\n",
    "        draw.polygon((x1,y1,x2,y2,x3,y3,x4,y4), outline=(255,0,0))\n",
    "        x4 = 4.0 * (tree.x + (0.5 * tree.d) * math.cos(right+0.5 *math.pi) - (0.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "        y4 = 4.0 * (tree.y + (0.0 * tree.h) * math.cos(right+0.5 *math.pi) + (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "        x3 = 4.0 * (tree.x - (0.5 * tree.d) * math.cos(right+0.5 *math.pi) - (0.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "        y3 = 4.0 * (tree.y + (0.0 * tree.h) * math.cos(right+0.5 *math.pi) - (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "        x1 = 4.0 * (tree.x + (0.5 * tree.d) * math.cos(right+0.5 *math.pi) + (1.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "        y1 = 4.0 * (tree.y - (1.0 * tree.h) * math.cos(right+0.5 *math.pi) + (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "        x2 = 4.0 * (tree.x - (0.5 * tree.d) * math.cos(right+0.5 *math.pi) + (1.0 * tree.h) * math.sin(right+0.5 *math.pi))\n",
    "        y2 = 4.0 * (tree.y - (1.0 * tree.h) * math.cos(right+0.5 *math.pi) - (0.5 * tree.d) * math.sin(right+0.5 *math.pi))\n",
    "        draw.polygon((x1,y1,x2,y2,x3,y3,x4,y4), outline=(255,0,0))\n",
    "        return True\n",
    "      if right > limit:\n",
    "        limit = right\n",
    "    return limit + epsilon < 2.0 * math.pi\n",
    "\n",
    "def main():\n",
    "  case_num = 1\n",
    "  with open('uva1003.in', 'r') as f:\n",
    "    while True:\n",
    "        nums = list(map(int, f.readline().split()))\n",
    "        if not any(nums):\n",
    "          break\n",
    "        ##print(list(nums))\n",
    "        x_min, y_min, x_max, y_max, num_trees = list(nums)\n",
    "        trees = [Tree(*map(int, f.readline().split())) for _ in range(0, num_trees)]\n",
    "        handle_case(case_num, x_min, y_min, x_max, y_max, trees)\n",
    "        case_num += 1\n",
    "\n",
    "def handle_case(case_num, x_min, y_min, x_max, y_max, trees):\n",
    "  remain = set(range(len(trees)))\n",
    "  base = Image.new('RGB', (802, 802), (255,255,255))\n",
    "  draw = ImageDraw.Draw(base)\n",
    "  draw.rectangle((8.0*x_min, 8.0*y_min, 8.0*x_max, 8.0*y_max), outline=(0,0,0))\n",
    "\n",
    "  while remain:\n",
    "    progress = False\n",
    "    for i, tree in enumerate(trees):\n",
    "      max_fall = math.sqrt((0.5 * tree.d) * (0.5 * tree.d) + tree.h * tree.h)\n",
    "      draw.ellipse((8.0*(tree.x-(0.5 * tree.d)), 8.0*(tree.y-(0.5*tree.d)),8.0*(tree.x+(0.5 * tree.d)), 8.0*(tree.y+(0.5*tree.d))), outline=(0,0,0))\n",
    "      ##draw.ellipse((4*(tree.x-max_fall), 4*(tree.y-max_fall),4*(tree.x+max_fall), 4*(tree.y+max_fall)), outline=(0,0,255))\n",
    "      if i not in remain:\n",
    "        continue\n",
    "      obs = ObstacleSet(0.5 * tree.d, tree.h, x_min, x_max, y_min, y_max)\n",
    "      obs.add_fence(x_max - tree.x, 0, tree, draw)\n",
    "      obs.add_fence(y_max - tree.y, 0.5 * math.pi, tree, draw)\n",
    "      obs.add_fence(tree.x - x_min, math.pi, tree, draw)\n",
    "      obs.add_fence(tree.y - y_min, 1.5 * math.pi, tree, draw)\n",
    "      for j, tree2 in enumerate(trees):\n",
    "        if j == i or j not in remain:\n",
    "          continue\n",
    "        dx = tree2.x - tree.x\n",
    "        dy = tree2.y - tree.y\n",
    "        if dy > 0:\n",
    "          if dx > 0:\n",
    "            angle = math.atan2(dy, dx)\n",
    "          else:\n",
    "            angle = math.atan2(-dx, dy) + 0.5 * math.pi\n",
    "        else:\n",
    "          if dx < 0:\n",
    "            angle = math.atan2(-dy, -dx) + math.pi\n",
    "          else:\n",
    "            angle = math.atan2(dx, -dy) + 1.5 * math.pi\n",
    "        obs.add_tree(math.sqrt(dx * dx + dy * dy), 0.5 * tree2.d, angle, tree, draw)\n",
    "      if obs.has_gap(tree, draw):\n",
    "        ##print(\"found tree %d forest %d\" % (i, case_num))\n",
    "        remain.discard(i)\n",
    "        progress = True\n",
    "    if not progress:\n",
    "      break\n",
    "  display(base)\n",
    "  print('Forest {}\\n{} tree(s) can be cut\\n'.format(case_num, len(trees) - len(remain)))\n",
    "\n",
    "main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
